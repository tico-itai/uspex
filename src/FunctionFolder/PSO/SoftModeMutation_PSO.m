function SoftModeMutation_PSO(Ind_No)
global POP_STRUC
global ORG_STRUC
global OFF_STRUC
goodAtomMutant = 0;
goodMutLattice = 0;
structureFailed = 0;
while goodAtomMutant + goodMutLattice ~= 2
ind  = Ind_No;
numIons = POP_STRUC.POPULATION(ind).numIons;
N = sum(numIons);
lat = POP_STRUC.POPULATION(ind).LATTICE;
coor = POP_STRUC.POPULATION(ind).COORDINATES;
FINGERPRINT = POP_STRUC.POPULATION(ind).FINGERPRINT;
flag = 0;
maxSoftMode = N;  
for j = 1 : length(POP_STRUC.SOFTMODEParents)
dist_ij = cosineDistance(FINGERPRINT, POP_STRUC.SOFTMODEParents(j).fingerprint, ORG_STRUC.weight);
if dist_ij < ORG_STRUC.toleranceFing
[freq, eigvector] = calcSoftModes(ORG_STRUC.NvalElectrons, ORG_STRUC.valences, numIons, lat, coor);
freq = diag(freq);
[freq, IX] = sort(freq);
L_char = (det(lat)/N)^(1/3); 
ff = 0;
non_zero = 0;
last_good = POP_STRUC.SOFTMODEParents(j).Softmode_Fre;
maxSoftModeFreq = freq(maxSoftMode);
if ORG_STRUC.doFing
if (last_good <= maxSoftModeFreq)
[MUT_LAT0, MUT_COORD0, deviation0] = move_along_SoftMode_Mutation(POP_STRUC.SOFTMODEParents(j).coordinates, numIons, lat, eigvector(:,IX(POP_STRUC.SOFTMODEParents(j).Softmode_num)), 1);
[Ni, V, dist_matrix, typ_i, typ_j] = makeMatrices(MUT_LAT0, MUT_COORD0, numIons, ORG_STRUC.atomType);
[order0, fingerprint0, atom_fing0] = fingerprint_calc(Ni, V, dist_matrix, typ_i, typ_j, numIons);
end
end
for i = 1 : length(freq)
if freq(i) < last_good
continue;
end
quite_different = 0;
if ORG_STRUC.doFing
if (freq(i) <= maxSoftModeFreq)
[MUT_LAT0, MUT_COORD0, deviation0] = move_along_SoftMode_Mutation(POP_STRUC.SOFTMODEParents(j).coordinates, numIons, lat, eigvector(:,IX(i)), 1);
[Ni, V, dist_matrix, typ_i, typ_j] = makeMatrices(MUT_LAT0, MUT_COORD0, numIons, ORG_STRUC.atomType);
[order1, fingerprint1, atom_fing1] = fingerprint_calc(Ni, V, dist_matrix, typ_i, typ_j, numIons);
if (cosineDistance(fingerprint0, fingerprint1, ORG_STRUC.weight) > ORG_STRUC.toleranceFing)
quite_different = 1;
end
else 
non_zero = maxSoftMode + 1;
break;
end
elseif freq(i) > (1.05)*last_good
quite_different = 1;
end
if quite_different == 1
non_zero = i;
break
end
end
if non_zero == 0  
Mutation_300(Ind_No);
logic1 = 1;
logic2 = 1;
else
opposite_degenerate = 0;
current_freq = non_zero;
good_freq = non_zero;
loop = 0;
logic1 = 0;
logic2 = 0;
for f = good_freq : non_zero + round((3*N-non_zero)/1.5)  
if loop==1
break
else
for i = 0 : 10
if f > maxSoftMode   
stoch_vect = (2*rand-1)*eigvector(:,IX(1));
for st = 2 : maxSoftMode
stoch_vect = stoch_vect + (2*rand-1)*eigvector(:,IX(st));
end
[MUT_LAT, MUT_COORD, deviation] = move_along_SoftMode_Mutation(POP_STRUC.SOFTMODEParents(j).coordinates, numIons, lat, stoch_vect, 1-i/21);
else
[MUT_LAT, MUT_COORD, deviation] = move_along_SoftMode_Mutation(POP_STRUC.SOFTMODEParents(j).coordinates, numIons, lat, eigvector(:,IX(f)), 1-i/21);
end
goodAtomMutant = distanceCheck(MUT_COORD, MUT_LAT, numIons, ORG_STRUC.minDistMatrice);
structureFailed = structureFailed + 1 - goodAtomMutant;
if structureFailed >= 100
%disp('Distance check failed more than 100 times in a single softmutation.')
USPEXmessage(513,'',0);
structureFailed = 0;
end
goodMutLattice = 1; 
if goodAtomMutant + goodMutLattice == 2
if ORG_STRUC.doFing & (f <= maxSoftMode)
[Ni, V, dist_matrix, typ_i, typ_j] = makeMatrices(MUT_LAT, MUT_COORD, numIons, ORG_STRUC.atomType);
[order0, fingerprint0, atom_fing0] = fingerprint_calc(Ni, V, dist_matrix, typ_i, typ_j, numIons);
[MUT_LAT1, MUT_COORD1, deviation1] = move_along_SoftMode_Mutation(POP_STRUC.SOFTMODEParents(j).coordinates, numIons, lat, -1*eigvector(:,IX(f)), 1-i/21);
[Ni, V, dist_matrix, typ_i, typ_j] = makeMatrices(MUT_LAT1, MUT_COORD1, numIons, ORG_STRUC.atomType);
[order1, fingerprint1, atom_fing1] = fingerprint_calc(Ni, V, dist_matrix, typ_i, typ_j, numIons);
if (cosineDistance(fingerprint0, fingerprint1, ORG_STRUC.weight) <= ORG_STRUC.toleranceFing)
opposite_degenerate = 1;
end
end
logic1 = 1;
OFF_STRUC.POPULATION(Ind_No).COORDINATES = MUT_COORD;
OFF_STRUC.POPULATION(Ind_No).LATTICE = MUT_LAT;
info_parents = struct('parent', {},'mut_degree', {},'mut_mode',{},'mut_fre',{},'enthalpy',{});
info_parents(1).parent = num2str(POP_STRUC.POPULATION(ind).Number);
info_parents.mut_degree = deviation;
info_parents.mut_mode = f;
info_parents.mut_fre = freq(f);
info_parents.enthalpy = POP_STRUC.POPULATION(ind).Enthalpies(end)/sum(numIons);
if f > maxSoftMode   
disp(['Structure ' num2str(Ind_No) ' generated by softmutation -- from database']);
else
disp(['Structure ' num2str(Ind_No) ' generated by softmutation -- from database']);
end
OFF_STRUC.POPULATION(Ind_No).Parents = info_parents;
OFF_STRUC.POPULATION(Ind_No).numIons = numIons;
OFF_STRUC.POPULATION(Ind_No).howCome = 'softmutate';
POP_STRUC.SOFTMODEParents(j).Softmode_Fre = freq(f);
POP_STRUC.SOFTMODEParents(j).Softmode_num = f;
loop = 1;
break;
elseif (i == 21) & (f == non_zero + round((3*N-non_zero)/2))
break;
end
end
for i = 0 : 10
if (f > maxSoftMode) & (logic1 == 1)  
break;
elseif opposite_degenerate == 1 
break;
elseif f > maxSoftMode    
stoch_vect = (2*rand-1)*eigvector(:,IX(1));
for st = 2 : maxSoftMode
stoch_vect = stoch_vect + (2*rand-1)*eigvector(:,IX(st));
end
[MUT_LAT, MUT_COORD, deviation] = move_along_SoftMode_Mutation(POP_STRUC.SOFTMODEParents(j).coordinates, numIons, lat, stoch_vect, 1-i/21);
else
[MUT_LAT, MUT_COORD, deviation] = move_along_SoftMode_Mutation(POP_STRUC.SOFTMODEParents(j).coordinates, numIons, lat,-1*eigvector(:,IX(f)), 1-i/21);
end
goodAtomMutant = distanceCheck(MUT_COORD, MUT_LAT, numIons, ORG_STRUC.minDistMatrice);
structureFailed = structureFailed + 1 - goodAtomMutant;
if structureFailed >= 100
%disp('Distance check failed more than 100 times in a single softmutation.')
USPEXmessage(513,'',0);
structureFailed = 0;
end
goodMutLattice = 1; 
if goodAtomMutant + goodMutLattice == 2
if ORG_STRUC.dimension == 0
[MUT_LAT,MUT_COORD] = reduce_Cluster(MUT_LAT,MUT_COORD);
end
logic2 = 1;
info_parents = struct('parent', {},'mut_degree', {},'mut_mode',{},'mut_fre',{}, 'enthalpy',{});
info_parents(1).parent = num2str(POP_STRUC.POPULATION(ind).Number);
info_parents.mut_degree = deviation;
info_parents.mut_mode = f;
info_parents.mut_fre = freq(f);
info_parents.enthalpy = POP_STRUC.POPULATION(ind).Enthalpies(end)/sum(numIons);
if logic1 == 1
OFF_STRUC.POPULATION(end+1).COORDINATES = MUT_COORD;
OFF_STRUC.POPULATION(end).LATTICE = MUT_LAT;
OFF_STRUC.POPULATION(end).Parents = info_parents;
OFF_STRUC.POPULATION(end).numIons = numIons;
OFF_STRUC.POPULATION(end).howCome = 'softmutate';
else
OFF_STRUC.POPULATION(Ind_No).COORDINATES = MUT_COORD;
OFF_STRUC.POPULATION(Ind_No).LATTICE = MUT_LAT;
OFF_STRUC.POPULATION(Ind_No).Parents = info_parents;
OFF_STRUC.POPULATION(Ind_No).numIons = numIons;
OFF_STRUC.POPULATION(Ind_No).howCome = 'softmutate';
end
POP_STRUC.SOFTMODEParents(j).Softmode_Fre = freq(f);
POP_STRUC.SOFTMODEParents(j).Softmode_num = f;
if f > maxSoftMode   
disp(['Structure ' num2str(Ind_No) ' generated by softmutation -- from database']);
else
disp(['Structure ' num2str(Ind_No) ' generated by softmutation -- from database']);
end
loop = 1;
break;
elseif (i == 21) & (f == non_zero + round((3*N-non_zero)/2))
break;
end
end
end  
good_freq = good_freq + 1;
end  
end     
flag = 1;
break;    
end        
end          
if flag==0
[freq, eigvector] = calcSoftModes(ORG_STRUC.NvalElectrons, ORG_STRUC.valences, numIons, lat, coor);
freq = diag(freq);
[freq, IX] = sort(freq);
for i = 1:length(freq)        
if freq(i) > 0.0000001
non_zero = i;
break;
end
end
non_zero = 4; 
current_freq = non_zero;
good_freq = non_zero;
L_char = (det(lat)/N)^(1/3); 
ff = 0;
loop = 0;
logic1 = 0;
logic2 = 0;
opposite_degenerate = 0;
for f = good_freq : non_zero + round((3*N-non_zero)/1.5)  
if loop==1
break
else
for i = 0 : 10
[MUT_LAT, MUT_COORD, deviation] = move_along_SoftMode_Mutation(coor, numIons, lat, eigvector(:,IX(f)), 1-i/21);
goodAtomMutant = distanceCheck(MUT_COORD, MUT_LAT, numIons, ORG_STRUC.minDistMatrice);
structureFailed = structureFailed + 1 - goodAtomMutant;
if structureFailed >= 100
%disp('Distance check failed more than 100 times in a single softmutation.')
USPEXmessage(513,'',0);
structureFailed = 0;
end
goodMutLattice = 1; 
if goodAtomMutant + goodMutLattice == 2
if ORG_STRUC.doFing & (f <= maxSoftMode)
[Ni, V, dist_matrix, typ_i, typ_j] = makeMatrices(MUT_LAT, MUT_COORD, numIons, ORG_STRUC.atomType);
[order0, fingerprint0, atom_fing0] = fingerprint_calc(Ni, V, dist_matrix, typ_i, typ_j, numIons);
[MUT_LAT1, MUT_COORD1, deviation1] = move_along_SoftMode_Mutation(coor, numIons, lat, -1*eigvector(:,IX(f)), 1-i/21);
[Ni, V, dist_matrix, typ_i, typ_j] = makeMatrices(MUT_LAT1, MUT_COORD1, numIons, ORG_STRUC.atomType);
[order1, fingerprint1, atom_fing1] = fingerprint_calc(Ni, V, dist_matrix, typ_i, typ_j, numIons);
if (cosineDistance(fingerprint0, fingerprint1, ORG_STRUC.weight) <= ORG_STRUC.toleranceFing)
opposite_degenerate = 1;
end
end
logic1 = 1;
POP_STRUC.SOFTMODEParents(end+1).lattice = MUT_LAT;
POP_STRUC.SOFTMODEParents(end).coordinates = coor;
POP_STRUC.SOFTMODEParents(end).fingerprint = FINGERPRINT;
POP_STRUC.SOFTMODEParents(end).Softmode_Fre = freq(f);
POP_STRUC.SOFTMODEParents(end).Softmode_num = f;
POP_STRUC.SOFTMODEParents(end).numIons = numIons;
OFF_STRUC.POPULATION(Ind_No).COORDINATES = MUT_COORD;
OFF_STRUC.POPULATION(Ind_No).LATTICE = MUT_LAT;
ff = f;
info_parents = struct('parent', {},'mut_degree', {},'mut_mode',{},'mut_fre',{}, 'enthalpy', {});
info_parents(1).parent = num2str(POP_STRUC.POPULATION(ind).Number);
info_parents.mut_degree = deviation;
info_parents.mut_mode = f;
info_parents.mut_fre = freq(f);
info_parents.enthalpy = POP_STRUC.POPULATION(ind).Enthalpies(end)/sum(numIons);
disp(['Structure ' num2str(Ind_No) ' generated by softmutation -- from database']);
OFF_STRUC.POPULATION(Ind_No).Parents = info_parents;
OFF_STRUC.POPULATION(Ind_No).numIons = numIons;
OFF_STRUC.POPULATION(Ind_No).howCome = 'softmutate';
loop = 1;
break;
elseif (i == 21) & (f == non_zero + round((3*N-non_zero)/2))
break;
end
end
if opposite_degenerate == 1 
break;
end
for i = 0 : 10
[MUT_LAT, MUT_COORD, deviation] = move_along_SoftMode_Mutation(coor, numIons, lat, -1*eigvector(:,IX(f)), 1-i/21);
goodAtomMutant = distanceCheck(MUT_COORD, MUT_LAT, numIons, ORG_STRUC.minDistMatrice);
structureFailed = structureFailed + 1 - goodAtomMutant;
if structureFailed >= 100
%disp('Distance check failed more than 100 times in a single softmutation.')
USPEXmessage(513,'',0);
structureFailed = 0;
end
goodMutLattice = 1; 
if goodAtomMutant + goodMutLattice == 2
if ORG_STRUC.dimension == 0
[MUT_LAT,MUT_COORD] = reduce_Cluster(MUT_LAT,MUT_COORD);
end
logic2 = 1;
ff = f;
info_parents = struct('parent', {},'mut_degree', {},'mut_mode',{},'mut_fre',{}, 'enthalpy', {});
info_parents(1).parent = num2str(POP_STRUC.POPULATION(ind).Number);
info_parents.mut_degree = deviation;
info_parents.mut_mode = f;
info_parents.mut_fre = freq(f);
info_parents.enthalpy = POP_STRUC.POPULATION(ind).Enthalpies(end)/sum(numIons);
disp(['Structure ' num2str(Ind_No) ' generated by softmutation -- from new structure']);
% disp(['in opposite direction with frequency f = ' num2str(freq(f)*1000000) ' (a.u.; mode number ' num2str(f) ')']);
% disp(['Mutation_degree_max = ' num2str(max(deviation)) ', Mut_degree_average = ' num2str(mean(deviation))']);
if logic1 == 1
OFF_STRUC.POPULATION(end+1).COORDINATES = MUT_COORD;
OFF_STRUC.POPULATION(end).LATTICE = MUT_LAT;
OFF_STRUC.POPULATION(end).Parents = info_parents;
OFF_STRUC.POPULATION(end).numIons = numIons;
OFF_STRUC.POPULATION(end).howCome = 'softmutate';
else
OFF_STRUC.POPULATION(Ind_No).COORDINATES = MUT_COORD;
OFF_STRUC.POPULATION(Ind_No).LATTICE = MUT_LAT;
OFF_STRUC.POPULATION(Ind_No).Parents = info_parents;
OFF_STRUC.POPULATION(Ind_No).numIons = numIons;
OFF_STRUC.POPULATION(Ind_No).howCome = 'softmutate';
POP_STRUC.SOFTMODEParents(end+1).lattice = MUT_LAT;
POP_STRUC.SOFTMODEParents(end).coordinates = coor;
POP_STRUC.SOFTMODEParents(end).fingerprint = FINGERPRINT;
POP_STRUC.SOFTMODEParents(end).Softmode_Fre = freq(f);
POP_STRUC.SOFTMODEParents(end).Softmode_num = f;
POP_STRUC.SOFTMODEParents(end).numIons = numIons;
end
loop = 1;
break;
elseif (i == 21) & (f == non_zero + round((3*N-non_zero)/2))
break;
end
end
good_freq = good_freq+1;
end
end
end
if (logic1 == 0) & (logic2 == 0)
Mutation_300(Ind_No);
end
goodAtomMutant = 1;
goodMutLattice = 1;
end
